# Geotic ECS 專案分析與改良計畫

本文檔旨在分析現有的 Geotic Entity-Component-System (ECS) 函式庫的架構，並提出可以改良和增強的方向。

## 1. 現有專案架構分析

Geotic 是一個使用 TypeScript 編寫的 ECS 函式庫。其核心架構包含以下主要組件：

*   **Engine**: 最上層的容器，管理 `ComponentRegistry` 和 `PrefabRegistry`。負責註冊組件、預製體 (Prefab) 以及建立 `World` 實例。
*   **World**: 管理實體 (Entity) 和查詢 (Query) 的集合。負責實體的建立、銷毀、序列化和反序列化。
*   **Entity**: 代表一個遊戲物件或任何需要管理的個體。它是組件 (Component) 的容器，並使用位元遮罩 (`_cbits`) 進行高效的組件查詢。
*   **Component**: 資料的容器，可以附加到實體上以定義其特性或行為。組件可以定義生命週期方法和事件處理器。
*   **ComponentRegistry**: 管理組件類別的註冊，為每個組件分配唯一的鍵 (`_ckey`) 和位元值 (`_cbit`)。
*   **Query**: 允許高效地檢索具有特定組件組合的實體集合。
*   **Prefab / PrefabRegistry**: 支援實體範本的定義和實例化。
*   **EntityEvent**: 提供實體觸發事件和組件監聽事件的機制。

**主要架構特點**:

*   **解耦合**: ECS 模式本身促進了關注點分離。
*   **資料導向**: 強調實體作為資料 (組件) 的聚合。
*   **動態組合**: 可以透過新增/移除組件來動態改變實體的行為和資料。
*   **效率**:
    *   使用位元遮罩進行快速的組件存在檢查。
    *   查詢機制設計用於高效檢索實體。
*   **序列化/反序列化**: 支援 World 和 Entity 的序列化與反序列化。
*   **TypeScript**: 利用 TypeScript 提供靜態型別檢查，有助於程式碼維護。

## 2. 改良與增強方向建議

以下是針對 Geotic 函式庫提出的一些潛在改良與增強方向：

### 2.1. 增強型別安全與開發者體驗

*   **`Entity.add` 中更強的組件屬性型別**:
    *   **問題**: `entity.add(ComponentClass, properties)` 中的 `properties` 引數目前型別為 `any`。
    *   **建議**: 利用 TypeScript 的進階型別 (如 `ConstructorParameters`、對映型別) 從 `ComponentClass` 的建構函式或其靜態 `properties` 定義中推斷正確的屬性型別。
    *   **益處**: 改善開發者體驗，減少因組件初始化不正確導致的執行期錯誤。
*   **泛型化的 `Entity.get` 和 `Entity.has`**:
    *   **問題**: `entity.get(ComponentClass)` 可能回傳泛用的 `Component` 型別。
    *   **建議**: 將這些方法泛型化，例如 `entity.get<T extends Component>(clazz: ComponentClass<T>): T | undefined`。
    *   **益處**: 減少函式庫使用者進行型別轉換的需求。
*   **更嚴格的 `tsconfig.json` 選項**:
    *   **建議**: 啟用更嚴格的 TypeScript 編譯器選項，如 `strictNullChecks`, `noImplicitAny`, `noImplicitThis`, `alwaysStrict` (若尚未完全實施)。
    *   **益處**: 在編譯時期捕獲更多潛在錯誤。

### 2.2. 改善封裝與 API 設計

*   **減少對 Engine/World 內部成員的直接存取**:
    *   **問題**: `World.ts` 存取 `engine._components` 和 `engine._prefabs`。`Entity.ts` 存取 `world._candidate` 和 `world._destroyed`。
    *   **建議**: 在 `Engine` 和 `World` 中為這些互動引入公用 getter 方法或專用介面方法。
    *   **益處**: 更清晰的 API 協定，更易於重構，減少誤用風險。
*   **一致的命名約定**:
    *   **觀察**: 大多數內部屬性以 `_` 開頭。確保此約定一致應用於所有非公用成員。
    *   **益處**: 提高程式碼可讀性和可維護性。

### 2.3. 效能最佳化 (需進一步研究)

*   **實體與組件的物件池 (Object Pooling)**:
    *   **建議**: 對於效能要求高的應用 (例如有大量短生命週期實體/組件的遊戲)，考慮實作物件池以減少記憶體回收的負擔。
    *   **益處**: 減少 GC 停頓，可能帶來更流暢的效能。
    *   **注意**: 會增加複雜性，應透過基準測試證明其必要性。
*   **查詢最佳化**:
    *   **建議**: 分析是否有情境可以透過查詢快取或更複雜的資料結構進一步提升查詢速度，特別是對於複雜查詢或大量實體。
    *   **益處**: 加快系統執行速度。

### 2.4. 增強功能集

*   **反應式查詢 / 可觀察查詢 (Reactive Queries / Observable Queries)**:
    *   **建議**: 允許應用程式的其他部分訂閱查詢結果的變更 (實體進入/離開查詢)。
    *   **益處**: 簡化需要對實體組成變化做出反應的系統邏輯。
*   **系統 (System) 抽象/基礎類別**:
    *   **建議**: 提供一個可選的 `System` 基礎類別或介面，引導使用者。此類別可與 `World` 或 `Engine` 整合以進行更新，並自動管理相關查詢。
    *   **益處**: 提供更完整的 ECS 框架體驗。
*   **更完善的事件系統**:
    *   **建議**: 考慮如事件冒泡/捕獲、全域事件匯流排 (World/Engine 級別事件)、型別化事件等功能。
    *   **益處**: 更靈活和健壯的事件處理。
*   **World 與 Engine 的生命週期掛鉤 (Lifecycle Hooks)**:
    *   **建議**: 為 `World` 和 `Engine` 新增如 `onInitialize`, `onUpdateStart`, `onUpdateEnd`, `onDestroy` 等生命週期掛鉤。
    *   **益處**: 更好地與外部系統或遊戲迴圈整合。
*   **進階序列化/反序列化選項**:
    *   **建議**:
        *   支援在組件資料中參照實體 (例如，一個 `Target` 組件儲存另一個實體的 ID)。反序列化過程需要處理這些參照的解析。
        *   允許為特定組件型別自訂序列化/反序列化器。
    *   **益處**: 更強大和靈活的狀態管理。

### 2.5. 文件與範例

*   **API 文件產生**:
    *   **建議**: 使用 TypeDoc 等工具從 TSDoc 註解產生全面的 API 文件。
    *   **益處**: 使用者更容易理解和使用函式庫。
*   **更複雜的範例**:
    *   **建議**: 新增展示進階查詢、巢狀預製體、事件處理和簡單系統實作等功能的範例。
    *   **益處**: 協助使用者掌握函式庫的全部潛力。
*   **最佳實踐指南**:
    *   **建議**: 編寫一份文件，概述使用函式庫的最佳實踐。
    *   **益處**: 協助使用者使用 Geotic 編寫更高效和可維護的程式碼。

### 2.6. 測試

*   **提高測試覆蓋率**:
    *   **建議**: 確保所有功能都有高覆蓋率的測試，特別是邊界條件、序列化/反序列化和查詢邏輯。
    *   **益處**: 更健壯和可靠的函式庫。
*   **效能基準測試**:
    *   **建議**: 擴展現有的基準測試 (`benchmark.ts`) 以涵蓋更多情境，並定期執行追蹤。
    *   **益處**: 有助於識別效能回歸並驗證最佳化。

## 3. TODO 子任務表 (初步)

以下是根據上述改良建議制定的初步 TODO 子任務列表。在實施前，每個任務都應進一步細化。

### 3.1. 型別安全與開發者體驗
*   [x] **T1.1**: 研究並實作 `Entity.add` 的強型別 `properties`。(已增強 `Entity.add` 以從靜態 `properties` 或建構函式推斷型別)
*   [x] **T1.2**: 將 `Entity.get` 和 `Entity.has` 方法改為泛型。(已確認方法已為泛型)
*   [x] **T1.3**: 檢閱並強化 `tsconfig.json` 中的嚴格編譯選項，修正因此產生的型別錯誤。(已確認 `strict: true` 已啟用)

### 3.2. 封裝與 API 設計
*   [x] **T2.1**: 識別 `World` 和 `Entity` 中對 `Engine` 和 `World` 內部成員的直接存取點。(已識別並修正 `PrefabRegistry` 對 `Engine` 內部以及 `Query` 對 `World` 內部的存取)
*   [x] **T2.2**: 為 T2.1 中識別的存取點設計並實作公用介面/getter 方法。(已修改程式碼以使用現有的公用介面)
*   [x] **T2.3**: 檢閱專案，確保內部/私有成員的命名一致性 (例如，使用 `_` 前綴)。(已檢閱主要檔案，命名一致性良好，修正了 `Query.refresh` 中的存取問題)

### 3.3. 效能最佳化
*   [ ] **T3.1**: (研究) 評估在 Geotic 中引入物件池 (Entity/Component) 的潛在效益與複雜性。
*   [ ] **T3.2**: (研究) 分析現有查詢機制，找出潛在的效能瓶頸與最佳化空間。

### 3.4. 功能增強
*   [ ] **T4.1**: (研究/設計) 設計反應式/可觀察查詢的 API 與實作機制。
*   [ ] **T4.2**: (設計) 設計一個可選的 `System` 基礎類別/介面及其與 `World`/`Engine` 的整合方式。
*   [ ] **T4.3**: (研究/設計) 評估並設計更進階的事件系統功能 (如全域事件、型別化事件)。
*   [ ] **T4.4**: (設計) 確定 `World` 和 `Engine` 所需的生命週期掛鉤，並設計其 API。
*   [ ] **T4.5**: (研究/設計) 設計支援實體參照的序列化/反序列化機制。
*   [ ] **T4.6**: (設計) 設計允許自訂組件序列化器的機制。

### 3.5. 文件與範例
*   [ ] **T5.1**: 設定 TypeDoc 或類似工具，為專案產生 API 文件。
*   [ ] **T5.2**: 撰寫至少一個展示進階功能的複雜範例 (例如，包含系統邏輯的迷你遊戲片段)。
*   [ ] **T5.3**: 開始撰寫 Geotic 函式庫使用的最佳實踐指南。

### 3.6. 測試
*   [ ] **T6.1**: 分析目前測試覆蓋率 (可使用工具輔助)。
*   [x] **T6.2**: 針對測試覆蓋率較低的模組或功能，編寫新的單元/整合測試。(已修復現有測試中的錯誤)
*   [ ] **T6.3**: 擴展 `benchmark.ts`，加入更多效能測試情境 (如大量實體建立/銷毀、複雜查詢)。

---

請檢閱此計畫。確認後即可開始逐步實施。
